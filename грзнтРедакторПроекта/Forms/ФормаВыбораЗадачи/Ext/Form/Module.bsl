#Область ФормаИСобытияФормы

&НаКлиенте
Перем тСоответствиеТаблицыУИД;

&НаКлиенте
Перем тСоответствиеТаблицыРодитель;

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	ПредшественникУИД = Параметры.ПредшественникУИД;
	ТекущийУИД = Параметры.ТекущийУИД;
	ОперацияВыбора = Параметры.ОперацияВыбора;
	ПоказатьКнопкиКоличествоУровнейНаСервере(14);
	
	УстановитьПривилегированныйРежим(Истина);
	//ВыборЗадачиИсточникаЗаполнения
	//"ВыборПредшественника"
	//"ВыборРодителя"
	Если ОперацияВыбора = "ВыборПредшественника" Тогда
		ЗапросОпубликованныеЗадачи = новый Запрос;
		ЗапросОпубликованныеЗадачи.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	грзнтОпубликованныеЗадачиСрезПоследних.Проект,
		|	грзнтОпубликованныеЗадачиСрезПоследних.Задача,
		|	грзнтОпубликованныеЗадачиСрезПоследних.ПредставлениеПроекта КАК ПроектПредставление,
		|	грзнтОпубликованныеЗадачиСрезПоследних.ПредставлениеЗадачи КАК ЗадачаПредставление,
		|	ЕСТЬNULL(грзнтСрокиПроектов.ДатаНачала, ДАТАВРЕМЯ(1, 1, 1)) КАК ДатаНачала,
		|	ЕСТЬNULL(грзнтСрокиПроектов.ДатаОкончания, ДАТАВРЕМЯ(1, 1, 1)) КАК ДатаОкончания
		|ИЗ
		|	РегистрСведений.грзнтОпубликованныеЗадачи.СрезПоследних(
		|			&ДатаСреза,
		|			Проект <> &Проект
		|			И (ПроектИспользования = &Проект
		|				ИЛИ ПроектИспользования = ЗНАЧЕНИЕ(Справочник.Проекты.ПустаяСсылка))) КАК грзнтОпубликованныеЗадачиСрезПоследних
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.грзнтСрокиПроектов КАК грзнтСрокиПроектов
		|		ПО грзнтОпубликованныеЗадачиСрезПоследних.Задача = грзнтСрокиПроектов.Задача
		|			И грзнтОпубликованныеЗадачиСрезПоследних.Проект.грзнтРедактируемыйЭкземплярВерсии = грзнтСрокиПроектов.ЭкземплярВерсии
		|ГДЕ
		|	грзнтОпубликованныеЗадачиСрезПоследних.СтатусПубликации = ЗНАЧЕНИЕ(Перечисление.грзнтСтатусПубликацииЗадачи.Опубликована)";
		ЗапросОпубликованныеЗадачи.УстановитьПараметр("Проект", Параметры.Проект);
		ЗапросОпубликованныеЗадачи.УстановитьПараметр("ДатаСреза", ТекущаяДата());
		ВыборкаОпубликованныеЗадачи = ЗапросОпубликованныеЗадачи.Выполнить().Выбрать();
		Пока ВыборкаОпубликованныеЗадачи.Следующий() Цикл
			СтрокаВнешниеПредшественники = ТаблицаВнешниеПредшественники.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаВнешниеПредшественники, ВыборкаОпубликованныеЗадачи);
			СтрокаВнешниеПредшественники.ПроектУИД = ВыборкаОпубликованныеЗадачи.Проект.УникальныйИдентификатор();
			СтрокаВнешниеПредшественники.ЗадачаУИД = ВыборкаОпубликованныеЗадачи.Задача.УникальныйИдентификатор();
		КонецЦикла;
	Иначе
		Элементы.ГруппаСтраницаЗадачиОпубликованные.Видимость = Ложь;
	КонецЕсли;
	Параметры.Свойство("ВидПлана", ВидПлана);
	УстановитьПривилегированныйРежим(Ложь);
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	тСоответствиеТаблицыРодитель = Новый Соответствие;
	тСоответствиеТаблицыУИД = Новый Соответствие;
	
	ТекущийВладелец = ВладелецФормы;
	Пока ТипЗнч(ТекущийВладелец) <> Тип("УправляемаяФорма") Цикл
		ТекущийВладелец = ТекущийВладелец.Родитель;
	КонецЦикла;
	Если ТекущийВладелец.ВладелецФормы <> Неопределено Тогда 
		Если ОперацияВыбора <> "ВыборЗадачиПомещения" Тогда
			Для Каждого СтрокаСвязи ИЗ ТекущийВладелец.ТаблицаСвязей Цикл
				СтрокаПредшественник = ТаблицаПредшественники.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаПредшественник, СтрокаСвязи);
				СтрокаПредшественник.УИД = ТекущийУИД;
			КонецЦикла;
		КонецЕсли;
		
		ТекущийВладелец = ТекущийВладелец.ВладелецФормы;
		Пока ТипЗнч(ТекущийВладелец) <> Тип("УправляемаяФорма") Цикл
			ТекущийВладелец = ТекущийВладелец.Родитель;
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого СтрокаСвязи ИЗ ТекущийВладелец.ТаблицаПредшественники Цикл
		Если СтрокаСвязи.УИД = ТекущийУИД Тогда
			Продолжить;
		КонецЕсли;
		СтрокаПредшественник = ТаблицаПредшественники.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаПредшественник, СтрокаСвязи);
	КонецЦикла;
	
	Пропустить = Ложь;
	Если ОперацияВыбора = "ВыборРодителя" Тогда
		Если ТекущийВладелец.ДеревоПроекта.ПолучитьЭлементы().Количество() > 0 И ТекущийВладелец.ДеревоПроекта.ПолучитьЭлементы().Получить(0).КодСДР <> "0" Тогда
			СтрокаДерева = ДеревоПроекта.ПолучитьЭлементы().Добавить();
			СтрокаДерева.НаименованиеЗадачи = "<<< Корень дерева >>>";
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого СтрокаПроектаКопия ИЗ ТекущийВладелец.ТаблицаПроектаКопия Цикл
		Если СтрокаПроектаКопия.Внешний Тогда
			Продолжить;
		КонецЕсли;
		СтрокаПроекта = ТаблицаПроекта.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаПроекта, СтрокаПроектаКопия);
		СтрокаПроекта.ИдентификаторВладельца = СтрокаПроекта.Идентификатор;
		СтрокаПроекта.Идентификатор = -1;
	КонецЦикла;
	ТаблицаПроекта.Сортировать("НомерСтрокиПроекта");
	
	Для Каждого СтрокаПроекта ИЗ ТаблицаПроекта Цикл
		тСоответствиеТаблицыУИД.Вставить(СтрокаПроекта.УИД, СтрокаПроекта);
		
		СтрокаДляСоответствияРодитель = ?(ПустаяСтрока(СтрокаПроекта.Родитель), " ", СтрокаПроекта.Родитель);
		МассивСоответствие = тСоответствиеТаблицыРодитель.Получить(СтрокаДляСоответствияРодитель);
		Если МассивСоответствие = Неопределено Тогда
			МассивСоответствие = Новый Массив;
		КонецЕсли;
		МассивСоответствие.Добавить(СтрокаПроекта);
		тСоответствиеТаблицыРодитель.Вставить(СтрокаДляСоответствияРодитель, МассивСоответствие);
	КонецЦикла;
	
	// ((( grznt.Solntsev 20.10.2016
	Если ТекущийВладелец.Элементы.Найти("ТаблицаФильтрРедактора") <> Неопределено Тогда
		Для Каждого СтрокаФильтра ИЗ ТекущийВладелец.ТаблицаФильтрРедактора Цикл
			ИспользоватьФильтр = ИспользоватьФильтр ИЛИ СтрокаФильтра.Использование;
		КонецЦикла;
	КонецЕсли;
	// ))) grznt.Solntsev 20.10.2016
	
	СформироватьДеревоИзТаблицыНаКлиенте(ДеревоПроекта, "", Пропустить);
	//СформироватьДеревоПроектаПоФильтрТаблице(ДеревоПроекта, Новый Массив);
	
	Для Каждого ЭлементДерева ИЗ ДеревоПроекта.ПолучитьЭлементы() Цикл
		Элементы.ДеревоПроекта.Развернуть(ЭлементДерева.ПолучитьИдентификатор(), Истина);
	КонецЦикла;
	Элементы.ДеревоПроекта.ТекущаяСтрока = ТекущийИдентификатор;
	
	ПоказатьКнопкиКоличествоУровней();
КонецПроцедуры

&НаКлиенте
Процедура ДеревоПроектаВыбор(Элемент, ВыбраннаяСтрока, Поле, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	КомандаВыбрать(Неопределено);
КонецПроцедуры

&НаКлиенте
Процедура КомандаВыбрать(Команда)
	Если Элементы.ГруппаСтраницыЗадачи.ТекущаяСтраница = Элементы.ГруппаСтраницаЗадачиОпубликованные Тогда
		ТекущиеДанные = Элементы.ТаблицаВнешниеПредшественники.ТекущиеДанные;
		Если ТекущиеДанные = Неопределено Тогда
			Возврат;
		КонецЕсли;
		СтруктураОповещения = Новый Структура("ПроектУИД, ЗадачаУИД, ПроектПредставление, ЗадачаПредставление, Внешний, ДатаНачала, ДатаОкончания");
		ЗаполнитьЗначенияСвойств(СтруктураОповещения, ТекущиеДанные);
		СтруктураОповещения.Внешний = Истина;
		ОповеститьОВыборе(СтруктураОповещения);
		Возврат;
	КонецЕсли;
	
	ТекущиеДанные = Элементы.ДеревоПроекта.ТекущиеДанные;
	Если ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ВыбранноеЗначение = ТекущиеДанные.УИД;
	Если ОперацияВыбора = "ВыборПредшественника" Тогда
		Если ЗначениеЗаполнено(ВыбранноеЗначение) Тогда
			Если ТекущийУИД = ВыбранноеЗначение Тогда
				ПоказатьПредупреждение(, "Выбранный элемент ссылается сам на себя. Выберите другого предшественника!", , "Ошибка выборка предшественника");
				Возврат;
			КонецЕсли;
			
			СтрокиДубль = Новый Массив;
			Для Каждого СтрокаПредшественник ИЗ ТаблицаПредшественники Цикл
				Если СтрокаПредшественник.УИД = ТекущийУИД И СтрокаПредшественник.ПредшественникУИД = ВыбранноеЗначение Тогда
					СтрокиДубль.Добавить(СтрокаПредшественник);
				КонецЕсли;
			КонецЦикла;
			Если СтрокиДубль.Количество() > 0 Тогда
				ПоказатьПредупреждение(, "Выбранный элемент уже используется в связи для текущей задачи. Выберите другого предшественника!", , "Ошибка выбора предшественника");
				Возврат;
			КонецЕсли;
			
			//Если НайтиПроектВЗависимости(ВыбранноеЗначение, ТекущийУИД) Тогда //ИЛИ НайтиПроектВЗависимости(ТекущийУИД, ВыбранноеЗначение) Тогда
			//	ПоказатьПредупреждение(, "Выбранный элемент уже используется в других задачах и образует циклическую связь. Выберите другого предшественника", , "Ошибка выбора предшественника");
			//	Возврат;
			//КонецЕсли;
			
			Для Каждого СтрокаПроекта ИЗ ТаблицаПроекта Цикл
				Если СтрокаПроекта.УИД = ТекущийУИД Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Пока НЕ ПустаяСтрока(СтрокаПроекта.Родитель) Цикл
				Для Каждого СтрокаРодитель ИЗ ТаблицаПроекта Цикл
					Если СтрокаРодитель.УИД = СтрокаПроекта.Родитель Тогда
						СтрокаПроекта = СтрокаРодитель;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПроекта.УИД = ВыбранноеЗначение Тогда
					ПоказатьПредупреждение(, "Выбранный элемент является родителем текущей задачи и образует циклическую связь. Выберите другого предшественника", , "Ошибка выбора предшественника");
					Возврат;
				КонецЕсли;
			КонецЦикла;
			
			//РезультатПроверки = ПроверитьВозможностьВыбораПредшественникаНаСервере(ВыбранноеЗначение);
			ТекущийВладелец = ВладелецФормы;
			Пока ТипЗнч(ТекущийВладелец) <> тип("УправляемаяФорма") Цикл
				ТекущийВладелец = ТекущийВладелец.Родитель;
			КонецЦикла;
			МассивСвязей = Новый Массив;
			Если ТекущийВладелец.ВладелецФормы <> Неопределено Тогда
				Для Каждого СтрокаСвязи ИЗ ТекущийВладелец.ТаблицаСвязей Цикл
					//Если НЕ ПустаяСтрока(СтрокаСвязи.УИД) И НЕ ПустаяСтрока(СтрокаСвязи.ПредшественникУИД) Тогда
						СтруктураСвязи = Новый Структура("УИД, ПредшественникУИД", ТекущийУИД);
						СтруктураСвязи.Вставить("ПредшественникУИД", СтрокаСвязи.ПредшественникУИД);
						МассивСвязей.Добавить(СтруктураСвязи);
					//КонецЕсли;
				КонецЦикла;
			//ИначеЕсли ТекущийВладелец.Свойство("ТаблицаПредшественников") Тогда
			Иначе
				Для Каждого СтрокаСвязи ИЗ ТекущийВладелец.ТаблицаПредшественники Цикл
					Если СтрокаСвязи.УИД = ТекущийУИД Тогда
						СтруктураСвязи = Новый Структура("УИД, ПредшественникУИД", ТекущийУИД);
						СтруктураСвязи.Вставить("ПредшественникУИД", СтрокаСвязи.ПредшественникУИД);
						МассивСвязей.Добавить(СтруктураСвязи);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			Если ТекущийВладелец.ВладелецФормы <> Неопределено Тогда
				ТекущийВладелец = ТекущийВладелец.ВладелецФормы;
			КонецЕсли;
			РезультатПроверки = "";
			//ТекущийВладелец.АдресВременногоХранилищаДанныхНаСервере = ТекущийВладелец.РекурсивныйПересчетПроверитьВозможностьПеремещения(ТекущийВладелец.АдресВременногоХранилищаДанныхНаСервере, ТекущийВладелец.УникальныйИдентификатор, ТекущийУИД, ВыбранноеЗначение, РезультатПроверки);
			ТекущийВладелец.АдресВременногоХранилищаДанныхНаСервере = ТекущийВладелец.РекурсивныйПересчетПроверитьВозможностьВыбораПредшественника(ТекущийВладелец.АдресВременногоХранилищаДанныхНаСервере, ТекущийВладелец.УникальныйИдентификатор, ТекущийУИД, ПредшественникУИД, ВыбранноеЗначение, МассивСвязей, РезультатПроверки);
			Если Не ПустаяСтрока(РезультатПроверки) Тогда
				ПоказатьПредупреждение(, РезультатПроверки + " Выберите другого предшественника!", , "Ошибка выбора предшественника");
				Возврат;
			КонецЕсли;	
		КонецЕсли;
		ОповеститьОВыборе(ТекущиеДанные.УИД);
	ИначеЕсли ОперацияВыбора = "ВыборЗадачиИсточникаЗаполнения" Тогда
		ТекущийВладелец = ВладелецФормы;
		Пока ТипЗнч(ТекущийВладелец) <> Тип("УправляемаяФорма") Цикл
			ТекущийВладелец = ТекущийВладелец.Родитель;
		КонецЦикла;
		Если ТекущийВладелец.ВладелецФормы <> Неопределено Тогда
			ТекущийВладелец = ТекущийВладелец.ВладелецФормы;
		КонецЕсли;
		
		СтрокаТаблицыПриемник = ТекущийВладелец.тСоответствиеТаблицыУИД.Получить(ТекущийУИД);
		СтрокаТаблицыИсточник = ТекущийВладелец.тСоответствиеТаблицыУИД.Получить(ТекущиеДанные.УИД);
		
		// сформируем будующих предшественников по примеру источника
		МассивПредшественники = Новый Массив;
		Для Каждого СтрокаПредшественник ИЗ СтрокаТаблицыИсточник.ТаблицаПредшественники Цикл
			// Да, здесь именно УИД строки приемника
			МассивПредшественники.Добавить(Новый Структура("УИД, ПредшественникУИД", СтрокаТаблицыПриемник.УИД, СтрокаПредшественник.ПредшественникУИД));
		КонецЦикла;
		
		// Проверим, можно ли вообще задать таких предшественников
		Если МассивПредшественники.Количество() > 0 Тогда
			
			МассивТекущие = Новый Массив;
			Для Каждого СтрокаПредшественник ИЗ СтрокаТаблицыПриемник.ТаблицаПредшественники Цикл
				МассивТекущие.Добавить(Новый Структура("УИД, ПредшественникУИД", СтрокаТаблицыПриемник.УИД, СтрокаПредшественник.ПредшественникУИД));
			КонецЦикла;
			
			РезультатПроверки = Неопределено;
			ТекущийВладелец.АдресВременногоХранилищаДанныхНаСервере = ТекущийВладелец.РекурсивныйПересчетПроверитьВозможностьЗаменыПредшественников(ТекущийВладелец.АдресВременногоХранилищаДанныхНаСервере, ТекущийВладелец.УникальныйИдентификатор, МассивТекущие, МассивПредшественники, РезультатПроверки);
			Если РезультатПроверки <> Неопределено Тогда
				СтрокаТаблицыПриемник = ТекущийВладелец.тСоответствиеТаблицыУИД.Получить(ТекущийУИД);
				СтрокаПредшественник = ТекущийВладелец.тСоответствиеТаблицыУИД.Получить(РезультатПроверки.ПредшественникУИД);
				СтрокаСообщения = "Строка №" + Формат(СтрокаТаблицыПриемник.НомерСтрокиПроекта, "ЧН=") + ?(СтрокаПредшественник = Неопределено, "", " предшественник №" + СтрокаПредшественник.НомерСтрокиПроекта) + Символы.ПС
					+ РезультатПроверки.Сообщение + " Выберите других предшественников!";
				
				ПоказатьПредупреждение(, СтрокаСообщения, , "Ошибка выбора предшественника");
				Возврат;
			КонецЕсли;
		КонецЕсли;
		
		//ОповеститьОВыборе(ТекущиеДанные.УИД);
		Оповестить("ВыборЗадачиИсточникаЗаполнения", Новый Структура("Приемник, Источник", ТекущийУИД, ТекущиеДанные.УИД), ЭтаФорма);
		Закрыть();
	ИначеЕсли ОперацияВыбора = "ВыборЗадачиИсточникаЗаполненияПлана" Тогда
		Если ВидПлана = "ТаблицаПредшественники" Тогда
			ТекущийВладелец = ВладелецФормы;
			Пока ТипЗнч(ТекущийВладелец) <> Тип("УправляемаяФорма") Цикл
				ТекущийВладелец = ТекущийВладелец.Родитель;
			КонецЦикла;
			Если ТекущийВладелец.ВладелецФормы <> Неопределено Тогда
				ТекущийВладелец = ТекущийВладелец.ВладелецФормы;
			КонецЕсли;
			
			СтрокаТаблицыПриемник = ТекущийВладелец.тСоответствиеТаблицыУИД.Получить(ТекущийУИД);
			СтрокаТаблицыИсточник = ТекущийВладелец.тСоответствиеТаблицыУИД.Получить(ТекущиеДанные.УИД);
			
			// сформируем будующих предшественников по примеру источника
			МассивПредшественники = Новый Массив;
			Для Каждого СтрокаПредшественник ИЗ СтрокаТаблицыИсточник.ТаблицаПредшественники Цикл
				// Да, здесь именно УИД строки приемника
				МассивПредшественники.Добавить(Новый Структура("УИД, ПредшественникУИД", СтрокаТаблицыПриемник.УИД, СтрокаПредшественник.ПредшественникУИД));
			КонецЦикла;
			
			// Проверим, можно ли вообще задать таких предшественников
			Если МассивПредшественники.Количество() > 0 Тогда
				
				МассивТекущие = Новый Массив;
				Для Каждого СтрокаПредшественник ИЗ СтрокаТаблицыПриемник.ТаблицаПредшественники Цикл
					МассивТекущие.Добавить(Новый Структура("УИД, ПредшественникУИД", СтрокаТаблицыПриемник.УИД, СтрокаПредшественник.ПредшественникУИД));
				КонецЦикла;
				
				РезультатПроверки = Неопределено;
				ТекущийВладелец.АдресВременногоХранилищаДанныхНаСервере = ТекущийВладелец.РекурсивныйПересчетПроверитьВозможностьЗаменыПредшественников(ТекущийВладелец.АдресВременногоХранилищаДанныхНаСервере, ТекущийВладелец.УникальныйИдентификатор, МассивТекущие, МассивПредшественники, РезультатПроверки);
				Если РезультатПроверки <> Неопределено Тогда
					СтрокаТаблицыПриемник = ТекущийВладелец.тСоответствиеТаблицыУИД.Получить(ТекущийУИД);
					СтрокаПредшественник = ТекущийВладелец.тСоответствиеТаблицыУИД.Получить(РезультатПроверки.ПредшественникУИД);
					СтрокаСообщения = "Строка №" + Формат(СтрокаТаблицыПриемник.НомерСтрокиПроекта, "ЧН=") + ?(СтрокаПредшественник = Неопределено, "", " предшественник №" + СтрокаПредшественник.НомерСтрокиПроекта) + Символы.ПС
						+ РезультатПроверки.Сообщение + " Выберите других предшественников!";
					
					ПоказатьПредупреждение(, СтрокаСообщения, , "Ошибка выбора предшественника");
					Возврат;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Оповестить("ВыборЗадачиИсточникаЗаполненияПлана", Новый Структура("Приемник, Источник, ВидПлана", ТекущийУИД, ТекущиеДанные.УИД, ВидПлана), ЭтаФорма);
		Закрыть();
	ИначеЕсли ОперацияВыбора = "ВыборРодителя" Тогда
		ТекущийВладелец = ВладелецФормы;
		Пока ТипЗнч(ТекущийВладелец) <> тип("УправляемаяФорма") Цикл
			ТекущийВладелец = ТекущийВладелец.Родитель;
		КонецЦикла;
		Если ТекущийВладелец.ВладелецФормы <> Неопределено Тогда
			ТекущийВладелец = ТекущийВладелец.ВладелецФормы;
		КонецЕсли;
		РезультатПроверки = "";
		ТекущийВладелец.АдресВременногоХранилищаДанныхНаСервере = ТекущийВладелец.РекурсивныйПересчетПроверитьВозможностьПеремещения(ТекущийВладелец.АдресВременногоХранилищаДанныхНаСервере, ТекущийВладелец.УникальныйИдентификатор, ТекущийУИД, ВыбранноеЗначение, РезультатПроверки);
		Если НЕ ПустаяСтрока(РезультатПроверки) Тогда
			ПоказатьПредупреждение(, РезультатПроверки + " Выберите другого родителя!", , "Ошибка выбора родителя");
			Возврат;
		КонецЕсли;
		Оповестить("ВыборРодителя", ТекущиеДанные.УИД, ЭтаФорма);
		Закрыть();
	ИначеЕсли ОперацияВыбора = "ВыборЗадачиПомещения" Тогда
		Оповестить("ВыборЗадачиПомещения", ТекущиеДанные.УИД, ЭтаФорма);
		Закрыть();
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Функция ПроверитьВозможностьПеремещенияНаСервере(ВыбранноеЗначение)
	ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
	Результат = ОбработкаОбъект.ПроверитьВозможностьПеремещенияЭлемента(ТекущийУИД, ВыбранноеЗначение, ТаблицаПредшественники, ТаблицаПроекта);
	Возврат Результат;
КонецФункции

&НаСервере
Функция ПроверитьВозможностьВыбораПредшественникаНаСервере(ВыбранноеЗначение)
	ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
	Результат = ОбработкаОбъект.ПроверитьВозможностьВыбораПредшественника(ТекущийУИД, ПредшественникУИД, ВыбранноеЗначение, ТаблицаПредшественники, ТаблицаПроекта);
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункции

&НаКлиенте
Функция НайтиПроектВЗависимости(ИскомыйПроект, НачальныйПроект)
	//СтрокиЗависимости = ТаблицаПредшественники.НайтиСтроки(Новый Структура("ПредшественникУИД", НачальныйПроект));
	СтрокиЗависимости = Новый Массив;
	Для Каждого СтрокаЗависимости ИЗ ТаблицаПредшественники Цикл
		Если СтрокаЗависимости.ПредшественникУИД <> НачальныйПроект Тогда 
			Продолжить;
		КонецЕсли;
	//Для Каждого СтрокаЗависимости ИЗ СтрокиЗависимости Цикл
		Если СтрокаЗависимости.УИД = ИскомыйПроект Тогда
			Возврат Истина;
		КонецЕсли;
		Если НайтиПроектВЗависимости(ИскомыйПроект, СтрокаЗависимости.УИД) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

&НаСервере
Процедура СформироватьДерево(УзелДерева, УИД)
	СтрокиТаблицы = ТаблицаПроекта.НайтиСтроки(Новый Структура("Родитель", УИД));
	Для Каждого СтрокаТаблицы ИЗ СтрокиТаблицы Цикл
	//Для каждого СтрокаТаблицы ИЗ ТаблицаПроекта Цикл
		Если СтрокаТаблицы.Родитель <> УИД Тогда
			Продолжить;
		КонецЕсли;
		ЭлементДерева = УзелДерева.ПолучитьЭлементы().Добавить();
		ЗаполнитьЗначенияСвойств(ЭлементДерева, СтрокаТаблицы);
		Если СтрокаТаблицы.УИД = ПредшественникУИД Тогда
			ТекущийИдентификатор = ЭлементДерева.ПолучитьИдентификатор();
		КонецЕсли;
		СформироватьДерево(ЭлементДерева, ЭлементДерева.УИД);
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура СформироватьДеревоИзТаблицыНаКлиенте(УзелДереваТекущий, УИДРодителяВладелец, ПропуститьДерево)
	//тСоответствиеТаблицыУИД.Вставить(СтрокаПроекта.УИД, СтрокаПроекта);
	//СтрокаДляСоответствияРодитель = ?(ПустаяСтрока(СтрокаПроекта.Родитель), " ", СтрокаПроекта.Родитель);
	//МассивСоответствие = тСоответствиеТаблицыРодитель.Получить(СтрокаДляСоответствияРодитель);
	//Если МассивСоответствие = Неопределено Тогда
	//	МассивСоответствие = Новый Массив;
	//КонецЕсли;
	//МассивСоответствие.Добавить(СтрокаПроекта);
	//тСоответствиеТаблицыРодитель.Вставить(СтрокаДляСоответствияРодитель, МассивСоответствие);
	
	СтрокаДляСоответствияРодитель = ?(ПустаяСтрока(УИДРодителяВладелец), " ", УИДРодителяВладелец);
	МассивСоответствие = тСоответствиеТаблицыРодитель.Получить(СтрокаДляСоответствияРодитель);
	Если МассивСоответствие = Неопределено Тогда
		МассивСоответствие = Новый Массив;
	КонецЕсли;
	Для Каждого СтрокаПроекта ИЗ МассивСоответствие Цикл
		Если НЕ ПропуститьДерево И НЕ ИспользоватьФильтр ИЛИ СтрокаПроекта.ИдентификаторВладельца >= 0 Тогда
			ЭлементДереваТекущий = УзелДереваТекущий.ПолучитьЭлементы().Добавить();
			ЗаполнитьЗначенияСвойств(ЭлементДереваТекущий, СтрокаПроекта, "УИД, НаименованиеЗадачи, ВидЭлемента, КодСДР, НомерСтрокиПроекта");
			СтрокаПроекта.Идентификатор = ЭлементДереваТекущий.ПолучитьИдентификатор();
			Если ЭлементДереваТекущий.УИД = ПредшественникУИД Тогда
				ТекущийИдентификатор = ЭлементДереваТекущий.ПолучитьИдентификатор();
			КонецЕсли;
		Иначе
			СтрокаПроекта.Идентификатор = -1;
		КонецЕсли;
		Если ЭлементДереваТекущий <> Неопределено И ЭлементДереваТекущий.УИД = ТекущийУИД Тогда
			ПропуститьДерево = Истина;
		КонецЕсли;
		Если НЕ ИспользоватьФильтр ИЛИ СтрокаПроекта.ИдентификаторВладельца >= 0 Тогда
			СформироватьДеревоИзТаблицыНаКлиенте(ЭлементДереваТекущий, СтрокаПроекта.УИД, ПропуститьДерево);
			//СформироватьДеревоПроектаПоФильтрТаблице(ДеревоПроекта, Новый Массив);
		КонецЕсли;
		Если ЭлементДереваТекущий <> Неопределено И ЭлементДереваТекущий.УИД = ТекущийУИД Тогда
			ПропуститьДерево = Ложь;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

&НаСервере
Процедура ПоказатьКнопкиКоличествоУровнейНаСервере(МаксимальныйУровень)
	//мУровень = ВернутьМаксимальныйУровень(ДеревоПроекта, 0);
	мУровень = МаксимальныйУровень;
	Для К = 1 По мУровень Цикл
		ИмяКнопки = "КнопкаПоказатьУровень" + Формат(К, "ЧГ=;ЧН=");
		КнопкаУровня = Элементы.Найти(ИмяКнопки);
		Если КнопкаУровня = Неопределено  Тогда
			КнопкаУровня = Элементы.Добавить(ИмяКнопки, Тип("КнопкаФормы"), Элементы.ГруппаКнопкиСлева);
			КнопкаУровня.Заголовок = К;
			КнопкаУровня.Отображение = ОтображениеКнопки.Текст;
			КнопкаУровня.ИмяКоманды = "КомандаПоказатьУровень";
		КонецЕсли; 
	КонецЦикла;
	К = мУровень + 1;
	Пока Элементы.Найти("КнопкаПоказатьУровень" + Формат(К, "ЧГ=;ЧН=")) <> Неопределено Цикл
		//Элементы.Удалить(Элементы.Найти("КнопкаПоказатьУровень" + Формат(К, "ЧГ=;ЧН=")));
		К = К + 1;
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура КомандаПоказатьУровень(Команда)
	Если Найти(ТекущийЭлемент.Имя, "КнопкаПоказатьУровень") = 0 Тогда
		Возврат;
	КонецЕсли;
	Уровень = Число(СтрЗаменить(ТекущийЭлемент.Имя, "КнопкаПоказатьУровень", ""));
	ПоказатьУровеньДерева(ДеревоПроекта, Уровень, 1);
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Функция ВернутьМаксимальныйУровень(УзелДерева, ТекущийУровень)
	максУровень = ТекущийУровень;
	Для Каждого ЭлементДерева ИЗ УзелДерева.ПолучитьЭлементы() Цикл
		тУровень = ВернутьМаксимальныйУровень(ЭлементДерева, ТекущийУровень + 1);
		Если максУровень < тУровень Тогда 
			максУровень = тУровень;
		КонецЕсли;
	КонецЦикла;
	Возврат максУровень;
КонецФункции

&НаКлиенте
Процедура ПоказатьУровеньДерева(УзелДерева, Уровень, ТекущийУровень)
	Для Каждого ЭлементДерева ИЗ УзелДерева.ПолучитьЭлементы() Цикл
		Если Уровень = ТекущийУровень Тогда
			Если Элементы.ДеревоПроекта.Развернут(ЭлементДерева.ПолучитьИдентификатор()) Тогда
				Элементы.ДеревоПроекта.Свернуть(ЭлементДерева.ПолучитьИдентификатор());
			КонецЕсли;
		Иначе
			Если НЕ Элементы.ДеревоПроекта.Развернут(ЭлементДерева.ПолучитьИдентификатор()) Тогда
				Элементы.ДеревоПроекта.Развернуть(ЭлементДерева.ПолучитьИдентификатор());
			КонецЕсли;
			ПоказатьУровеньДерева(ЭлементДерева, Уровень, ТекущийУровень + 1);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура ПоказатьКнопкиКоличествоУровней()
	мУровень = ВернутьМаксимальныйУровень(ДеревоПроекта, 0);
	Для К = 1 По мУровень Цикл
		ИмяКнопки = "КнопкаПоказатьУровень" + Формат(К, "ЧГ=;ЧН=");
		КнопкаУровня = Элементы.Найти(ИмяКнопки);
		Если КнопкаУровня = Неопределено Тогда
			ПоказатьКнопкиКоличествоУровнейНаСервере(мУровень);
			Возврат;
		Иначе
			КнопкаУровня.Видимость = Истина;
		КонецЕсли; 
	КонецЦикла;
	К = мУровень + 1;
	Пока Элементы.Найти("КнопкаПоказатьУровень" + Формат(К, "ЧГ=;ЧН=")) <> Неопределено Цикл
		КнопкаУровня = Элементы.Найти("КнопкаПоказатьУровень" + Формат(К, "ЧГ=;ЧН="));
		КнопкаУровня.Видимость = Ложь;
		К = К + 1;
		//ПоказатьКнопкиКоличествоУровнейНаСервере();
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаВнешниеПредшественникиВыбор(Элемент, ВыбраннаяСтрока, Поле, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	КомандаВыбрать(Неопределено);
КонецПроцедуры

&НаКлиенте
Процедура КомандаИспользоватьФильтр(Команда)
	Если НЕ ИспользоватьФильтр Тогда
		ИспользоватьФильтр = Истина;
		
		ТекущаяСтрока = Элементы.ДеревоПроекта.ТекущаяСтрока;
		ТекущиеДанные = ДеревоПроекта.НайтиПоИдентификатору(ТекущаяСтрока);
		СтрокаПроекта = тСоответствиеТаблицыУИД.Получить(ТекущиеДанные.УИД);
		
		ДеревоПроекта.ПолучитьЭлементы().Очистить();
		Пропустить = Ложь;
		СформироватьДеревоИзТаблицыНаКлиенте(ДеревоПроекта, "", Пропустить);
		//СформироватьДеревоПроектаПоФильтрТаблице(ДеревоПроекта, Новый Массив);
		Если СтрокаПроекта.Идентификатор >= 0 Тогда
			Элементы.ДеревоПроекта.ТекущаяСтрока = СтрокаПроекта.Идентификатор;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура КомандаСнятьФильтр(Команда)
	Если ИспользоватьФильтр Тогда
		ИспользоватьФильтр = Ложь;
		
		ТекущаяСтрока = Элементы.ДеревоПроекта.ТекущаяСтрока;
		ТекущиеДанные = ДеревоПроекта.НайтиПоИдентификатору(ТекущаяСтрока);
		СтрокаПроекта = тСоответствиеТаблицыУИД.Получить(ТекущиеДанные.УИД);
		
		ДеревоПроекта.ПолучитьЭлементы().Очистить();
		Пропустить = Ложь;
		СформироватьДеревоИзТаблицыНаКлиенте(ДеревоПроекта, "", Пропустить);
		//СформироватьДеревоПроектаПоФильтрТаблице( ДеревоПроекта, Новый Массив);
		Если СтрокаПроекта.Идентификатор >= 0 Тогда
			Элементы.ДеревоПроекта.ТекущаяСтрока = СтрокаПроекта.Идентификатор;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Функция СформироватьДеревоПроектаПоФильтрТаблице(УзелДерева, МассивСтрокРодителей)
	ДобавилиСтроку = Ложь;
	
	СтрокаРодитель = ?(МассивСтрокРодителей.Количество() = 0, Неопределено, МассивСтрокРодителей.Получить(МассивСтрокРодителей.Количество() - 1));
	
	СтрокаДляСоответствияРодитель = ?(СтрокаРодитель = Неопределено, " ", СтрокаРодитель.УИД);
	СтрокиРодителя = тСоответствиеТаблицыРодитель.Получить(СтрокаДляСоответствияРодитель);
	Если СтрокиРодителя = Неопределено Тогда 
		СтрокиРодителя = Новый Массив;
	КонецЕсли;
		
		Для Каждого СтрокаПроекта ИЗ СтрокиРодителя Цикл
			Если СтрокаПроекта.Внешний Тогда
				Продолжить;
			КонецЕсли;
			СтрокаУдовлетворяетФильтру = ИспользоватьФильтр ИЛИ (СтрокаПроекта.ИдентификаторВладельца >= 0);
			Если СтрокаУдовлетворяетФильтру И СтрокаПроекта.Идентификатор < 0 Тогда
				Если УзелДерева = Неопределено И СтрокаРодитель = Неопределено Тогда
					УзелДерева = ДеревоПроекта;
				ИначеЕсли УзелДерева = Неопределено И СтрокаРодитель.Идентификатор < 0 Тогда
					СоздатьГруппыДереваПоМассивуРодителей(УзелДерева, МассивСтрокРодителей, ЭтаФорма);
				ИначеЕсли УзелДерева = Неопределено Тогда
					УзелДерева = ДеревоПроекта.НайтиПоИдентификатору(СтрокаРодитель.Идентификатор);
				КонецЕсли;
				НаборЭлементовДерева = УзелДерева.ПолучитьЭлементы();
				КоличествоЭлементов = НаборЭлементовДерева.Количество() - 1;
				Для ИндексВставки = 0 По КоличествоЭлементов Цикл
					Если НаборЭлементовДерева.Получить(ИндексВставки).КодСДР > СтрокаПроекта.КодСДР Тогда
						Прервать;
					КонецЕсли;
				КонецЦикла;
				СтрокаДерева = НаборЭлементовДерева.Вставить(ИндексВставки);
				//ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаПроекта, , стрКолонкиТаблицыИсключение);
				ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаПроекта);
				//СкопироватьВсеПланыИзСтрокиТаблицыВУзелДерева(СтрокаДерева, СтрокаПроекта, ЭтаФорма);
				
				СтрокаПроекта.Идентификатор = СтрокаДерева.ПолучитьИдентификатор();
				ДобавилиСтроку = Истина;
			ИначеЕсли СтрокаПроекта.Идентификатор < 0 Тогда
			    СтрокаДерева = Неопределено
			Иначе
				СтрокаДерева = ДеревоПроекта.НайтиПоИдентификатору(СтрокаПроекта.Идентификатор);
			КонецЕсли;
			
			МассивСтрокРодителей.Добавить(СтрокаПроекта);
			БылиДобавления = СформироватьДеревоПроектаПоФильтрТаблице(СтрокаДерева, МассивСтрокРодителей);
			МассивСтрокРодителей.Удалить(МассивСтрокРодителей.Количество() - 1);
			Если НЕ БылиДобавления И НЕ СтрокаУдовлетворяетФильтру И СтрокаПроекта.Идентификатор >= 0 Тогда
				Если СтрокаДерева = Неопределено Тогда
				ИначеЕсли СтрокаДерева.ПолучитьРодителя() = Неопределено Тогда
					ДеревоПроекта.ПолучитьЭлементы().Удалить(СтрокаДерева);
				Иначе
					СтрокаДерева.ПолучитьРодителя().ПолучитьЭлементы().Удалить(СтрокаДерева);
				КонецЕсли;
				СтрокаПроекта.Идентификатор = -1;
				//СтрокаПроекта.ИдентификаторСДР = -1;
			КонецЕсли;
			ДобавилиСтроку = ДобавилиСтроку ИЛИ БылиДобавления ИЛИ СтрокаУдовлетворяетФильтру;
		КонецЦикла;
	Возврат ДобавилиСтроку;
КонецФункции

&НаКлиенте
Функция СоздатьГруппыДереваПоМассивуРодителей(УзелДерева, МассивСтрокРодителей, ЭтаФорма)
	СоздалиНовый = Ложь;
	ПоследнийРодитель = ЭтаФорма.ДеревоПроекта;
	Для К = 0 По МассивСтрокРодителей.Количество() - 1 Цикл
		СтрокаТаблицы = МассивСтрокРодителей.Получить(К);
		Если СтрокаТаблицы.Идентификатор >= 0 Тогда
			ПоследнийРодитель = ЭтаФорма.ДеревоПроекта.НайтиПоИдентификатору(СтрокаТаблицы.Идентификатор);
		ИначеЕсли СтрокаТаблицы.Идентификатор < 0 Тогда
			Если СоздалиНовый Тогда
				ПоследнийРодитель = ПоследнийРодитель.ПолучитьЭлементы().Добавить();
			Иначе
				НаборЭлементовДерева = ПоследнийРодитель.ПолучитьЭлементы();
				КоличествоЭлементов = НаборЭлементовДерева.Количество() - 1;
				Для ИндексВставки = 0 По КоличествоЭлементов Цикл
					Если НаборЭлементовДерева.Получить(ИндексВставки).КодСДР > СтрокаТаблицы.КодСДР Тогда
						Прервать;
					КонецЕсли;
				КонецЦикла;
				ПоследнийРодитель = НаборЭлементовДерева.Вставить(ИндексВставки);
			КонецЕсли;
			
			ЗаполнитьЗначенияСвойств(ПоследнийРодитель, СтрокаТаблицы, , ЭтаФорма.стрКолонкиТаблицыИсключение);
			
			Для Каждого СтрокаПланаТаблицы ИЗ СтрокаТаблицы.ПланДвиженияДенежныхСредств Цикл
				НоваяСтрокаПлана = ПоследнийРодитель.ПланДвиженияДенежныхСредств.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрокаПлана, СтрокаПланаТаблицы);
			КонецЦикла;
			
			СтрокаТаблицы.Идентификатор = ПоследнийРодитель.ПолучитьИдентификатор();
			ПоследнийРодитель.ИндексТаблицы = ЭтаФорма.ТаблицаПроектаКопия.Индекс(СтрокаТаблицы);
			СоздалиНовый = Истина;СоздалиНовый = Истина;
		КонецЕсли;
	КонецЦикла;
	УзелДерева = ПоследнийРодитель;
	Возврат ПоследнийРодитель;
КонецФункции

#КонецОбласти